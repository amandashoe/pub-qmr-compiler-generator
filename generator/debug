ProblemDefinition { imp: ImplBlock { routed_gates: [CX, T], data: NamedTuple { name: "GateRealization", fields: [("path", VectorTy(LocationTy))] }, realize: ITE { cond: BinOp(Equals, Tuple([CallMethod { d: Gate, method: "gate_type", args: [] }]), Ident("CX")), then: MapIterExpr { container: CallFunction { func: "all_paths", args: [Ident("arch"), CallFunction { func: "vertical_neighbors", args: [MapAccess(GetData { d: Gate, access: Access("qubits", ArrayAccess(IndexLiteral(0), Nil)) }), GetData { d: Arch, access: Access("width", Nil) }, GetData { d: Arch, access: Access("height", Nil) }] }, CallFunction { func: "horizontal_neighbors", args: [MapAccess(GetData { d: Gate, access: Access("qubits", ArrayAccess(IndexLiteral(1), Nil)) }), GetAnonData { ident: "arch", access: Access("width", Nil) }] }, Extend { vec1: Extend { vec1: CallFunction { func: "values", args: [CallMethod { d: Step, method: "map", args: [] }] }, vec2: CallMethod { d: Arch, method: "magic_state_qubits", args: [] } }, vec2: FoldExpr { container: MapIterExpr { container: CallMethod { d: Step, method: "implemented_gates", args: [] }, bound_var: "x", func: GetAnonData { ident: "x", access: Access("implementation", TupleAccess(CallFunction { func: "path", args: [] }, Nil)) } }, init: EmptyVec, func: Extend { vec1: Ident("acc"), vec2: Ident("x") } } }] }, bound_var: "x", func: ImplConstructorExpr([("path", Ident("x"))]) }, els: MapIterExpr { container: CallFunction { func: "all_paths", args: [Ident("arch"), CallFunction { func: "vertical_neighbors", args: [MapAccess(GetData { d: Gate, access: Access("qubits", ArrayAccess(IndexLiteral(0), Nil)) }), GetData { d: Arch, access: Access("width", Nil) }, GetData { d: Arch, access: Access("height", Nil) }] }, FoldExpr { container: MapIterExpr { container: CallMethod { d: Arch, method: "magic_state_qubits", args: [] }, bound_var: "x", func: CallFunction { func: "horizontal_neighbors", args: [Ident("x"), GetAnonData { ident: "arch", access: Access("width", Nil) }] } }, init: EmptyVec, func: Extend { vec1: Ident("acc"), vec2: Ident("x") } }, Extend { vec1: Extend { vec1: CallFunction { func: "values", args: [CallMethod { d: Step, method: "map", args: [] }] }, vec2: CallMethod { d: Arch, method: "magic_state_qubits", args: [] } }, vec2: FoldExpr { container: MapIterExpr { container: CallMethod { d: Step, method: "implemented_gates", args: [] }, bound_var: "x", func: GetAnonData { ident: "x", access: Access("implementation", TupleAccess(CallFunction { func: "path", args: [] }, Nil)) } }, init: EmptyVec, func: Extend { vec1: Ident("acc"), vec2: Ident("x") } } }] }, bound_var: "x", func: ImplConstructorExpr([("path", Ident("x"))]) } } }, trans: TransitionBlock { data: NamedTuple { name: "Transition", fields: [("na", LocationTy)] }, apply: CallFunction { func: "identity_application", args: [Ident("step")] }, cost: FloatLiteral(0.0), get_transitions: Append { vec: EmptyVec, elem: TransitionConstructor([("na", LocationLiteral(0))]) } }, arch: Some(ArchitectureBlock { data: NamedTuple { name: "Arch", fields: [("magic_state_qubits", VectorTy(LocationTy)), ("alg_qubits", VectorTy(LocationTy)), ("width", IntTy), ("height", IntTy)] }, get_locations: Some(CallMethod { d: Arch, method: "alg_qubits", args: [] }) }), step: Some(StepBlock { cost: FloatLiteral(1.0) }) }